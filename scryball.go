package scryball

import (
	"database/sql"
	_ "embed"
	"fmt"
	"net/http"
	"os"
	"path/filepath"
	"sync"

	"github.com/ninesl/scryball/internal/client"
	"github.com/ninesl/scryball/internal/scryfall"
	_ "modernc.org/sqlite"
)

// Scryball manages Magic card data with local caching and Scryfall API integration.
//
// Components:
//   - db: SQLite database for persistent local cache
//   - client: HTTP client for Scryfall API requests
//   - queries: Type-safe database queries generated by sqlc
//
// Usage:
//   - Create with NewWithConfig() for independent instance
//   - Or use SetConfig() to configure global instance
//   - Then use Query methods to fetch cards
type Scryball struct {
	mu      sync.Mutex
	db      *ScryballDB
	client  *client.Client
	queries *scryfall.Queries
}

//go:embed schema.sql
var embeddedSchema string

// ScryballDB wraps sql.DB for some type safety.
//
// Embeds *sql.DB so all standard database methods are available.
type ScryballDB struct {
	*sql.DB
}

// OverwriteDB replaces the current database with a new one.
//
// Behavior:
//   - Atomically swaps database references
//   - Returns previous database for cleanup
//   - New database is immediately active for all operations
//   - Caller responsible for closing returned old database
//
// Returns:
//   - *ScryballDB: The previous database (caller should close)
//
// Warning: Ensure no concurrent operations during swap. Consider closing old DB.
func (s *Scryball) OverwriteDB(freshDB *ScryballDB) *ScryballDB {
	s.mu.Lock()
	defer s.mu.Unlock()
	temp := s.db
	s.db = freshDB
	return temp
}

// RetrieveDB returns the current database instance.
//
// Behavior:
//   - Returns direct reference to internal database
//   - Modifications affect all Scryball operations
//   - Use for direct SQL operations or debugging
//
// Returns:
//   - *ScryballDB: Current active database
//
// Warning: Direct database access bypasses caching logic. Prefer using Scryball methods.
func (s *Scryball) RetrieveDB() *ScryballDB {
	return s.db
}

// SetConfig initializes the global Scryball instance with custom configuration.
//
// Behavior:
//   - Creates a new Scryball instance with provided config
//   - Replaces the global CurrentScryball instance (protected by mutex)
//   - Subsequent calls to Query(), QueryCard(), etc. will use this instance
//
// Config fields:
//   - DBPath: File path for cache storage (optional, defaults to memory-only)
//   - Client: Custom HTTP client for API calls (optional, defaults to http.DefaultClient)
//   - AppUserAgent: User-Agent header for API calls (optional, defaults to "MTGScryball/1.0")
//
// Returns:
//   - error: Database creation errors or invalid configuration
//
// Note: Call this before using package-level Query functions to customize behavior.
func SetConfig(config ScryballConfig) error {
	scryball, err := NewWithConfig(config)
	if err != nil {
		return err
	}

	mu.Lock()
	CurrentScryball = scryball
	mu.Unlock()

	return nil
}

// ScryballConfig configures a Scryball instance.
type ScryballConfig struct {
	// DBPath is the file path for the database.
	// Default: "" (empty string) which keeps cache in memory only.
	// Set to a file path to save cache to disk (survives program restarts).
	// Parent directories will be created if they don't exist.
	DBPath string

	// Client is the HTTP client for Scryfall API requests.
	// Default: &http.Client{} (standard HTTP client with no timeout).
	// Customize for proxies, timeouts, or rate limiting.
	Client *http.Client

	// AppUserAgent is the User-Agent header for API requests.
	// Default: "MTGScryball/1.0".
	// Scryfall requests descriptive user agents to identify your app.
	AppUserAgent string
}

// NewSchema creates a new SQLite database with Scryball schema.
//
// Behavior:
//   - Empty string creates in-memory database (not saved to disk)
//   - For file paths: creates parent directories if they don't exist
//   - Creates a fresh *sql.DB wrapper *ScryballDB and applies schema
//   - Returns wrapped database ready for use in a Scryball (s.OverwriteDB)
//
// Parameters:
//   - dbPath: File path for SQLite database (empty string for in-memory)
//
// Returns:
//   - *ScryballDB: Initialized database with schema applied
//   - error: File system errors or database initialization errors
//
// Note: Primarily for internal use. End users should use SetConfig() or NewWithConfig().
func NewSchema(dbPath string) (*ScryballDB, error) {
	if dbPath == "" {
		db, err := sql.Open("sqlite", ":memory:")
		if err != nil {
			return nil, fmt.Errorf("failed to create in-memory database: %w", err)
		}

		if _, err := db.Exec(embeddedSchema); err != nil {
			db.Close()
			return nil, fmt.Errorf("failed to apply embedded schema: %w", err)
		}

		return &ScryballDB{DB: db}, nil
	}

	// Handle file-based database
	dir := filepath.Dir(dbPath)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return nil, fmt.Errorf("failed to create directory %s: %w", dir, err)
	}

	db, err := sql.Open("sqlite", dbPath)
	if err != nil {
		return nil, fmt.Errorf("failed to open database: %w", err)
	}

	if _, err := db.Exec(embeddedSchema); err != nil {
		db.Close()
		return nil, fmt.Errorf("failed to execute schema: %w", err)
	}

	return &ScryballDB{DB: db}, nil
}

// NewWithConfig creates a new Scryball instance without affecting the global instance.
//
// Behavior:
//   - Creates or opens database at specified path
//   - If DBPath is empty, cache stays in memory (lost on program exit)
//   - If DBPath is set, cache is saved to disk (survives restarts)
//   - Initializes Scryfall API client with provided options
//   - Returns independent instance (does not affect global CurrentScryball)
//   - Useful for concurrent operations with different caches
//
// Config fields:
//   - DBPath: File path for cache storage (optional, defaults to memory-only)
//   - Client: Custom HTTP client for API calls (optional)
//   - AppUserAgent: User-Agent header for API calls (optional)
//
// Returns:
//   - *Scryball: New independent Scryball instance
//   - error: Database errors or invalid configuration
//
// Note: Use SetConfig() to update global instance, or use returned instance directly.
func NewWithConfig(config ScryballConfig) (*Scryball, error) {
	// DBPath empty means in-memory database

	db, err := NewSchema(config.DBPath)
	if err != nil {
		return nil, fmt.Errorf("failed to create/open database: %w", err)
	}

	if config.AppUserAgent == "" {
		config.AppUserAgent = baseClientOptions.UserAgent
	}
	if config.Client == nil {
		config.Client = &http.Client{}
	}

	cClient, err := client.NewClientWithOptions(client.ClientOptions{
		APIURL:    baseClientOptions.APIURL,
		UserAgent: config.AppUserAgent,
		Accept:    baseClientOptions.Accept,
		Client:    config.Client,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to create client: %w", err)
	}

	queries := scryfall.New(db.DB)

	return &Scryball{
		db:      db,
		client:  cClient,
		queries: queries,
	}, nil
}

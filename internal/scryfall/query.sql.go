// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package scryfall

import (
	"context"
	"database/sql"
)

const addArenaOnlyEACard = `-- name: AddArenaOnlyEACard :exec
INSERT INTO arena_only_ea_cards (oracle_id) VALUES (?)
`

// Insert oracle_id into arena only EA cards table
func (q *Queries) AddArenaOnlyEACard(ctx context.Context, oracleID string) error {
	_, err := q.db.ExecContext(ctx, addArenaOnlyEACard, oracleID)
	return err
}

const addBannedCard = `-- name: AddBannedCard :exec
INSERT INTO banned_cards (oracle_id) VALUES (?)
`

// Insert oracle_id into banned cards table
func (q *Queries) AddBannedCard(ctx context.Context, oracleID string) error {
	_, err := q.db.ExecContext(ctx, addBannedCard, oracleID)
	return err
}

const addDigitalMechanicCard = `-- name: AddDigitalMechanicCard :exec
INSERT INTO digital_mechanic_cards (oracle_id, mechanic_keyword) VALUES (?, ?)
`

type AddDigitalMechanicCardParams struct {
	OracleID        string
	MechanicKeyword sql.NullString
}

// Insert oracle_id into digital mechanic cards table
func (q *Queries) AddDigitalMechanicCard(ctx context.Context, arg AddDigitalMechanicCardParams) error {
	_, err := q.db.ExecContext(ctx, addDigitalMechanicCard, arg.OracleID, arg.MechanicKeyword)
	return err
}

const addEternalArtisanException = `-- name: AddEternalArtisanException :exec
INSERT INTO eternal_artisan_exception (oracle_id) VALUES (?)
`

// Insert oracle_id into eternal artisan exception table
func (q *Queries) AddEternalArtisanException(ctx context.Context, oracleID string) error {
	_, err := q.db.ExecContext(ctx, addEternalArtisanException, oracleID)
	return err
}

const addWatchlistCard = `-- name: AddWatchlistCard :exec
INSERT INTO watchlist_cards (oracle_id) VALUES (?)
`

// Insert oracle_id into watchlist cards table
func (q *Queries) AddWatchlistCard(ctx context.Context, oracleID string) error {
	_, err := q.db.ExecContext(ctx, addWatchlistCard, oracleID)
	return err
}

const cardExistsByOracleID = `-- name: CardExistsByOracleID :one
SELECT COUNT(*) FROM cards WHERE oracle_id = ? LIMIT 1
`

// Check if a card exists by oracle_id
func (q *Queries) CardExistsByOracleID(ctx context.Context, oracleID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, cardExistsByOracleID, oracleID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteOldQueryCache = `-- name: DeleteOldQueryCache :exec
DELETE FROM query_cache
WHERE cached_at < ?
`

// Delete old query cache entries (older than specified timestamp)
func (q *Queries) DeleteOldQueryCache(ctx context.Context, cachedAt string) error {
	_, err := q.db.ExecContext(ctx, deleteOldQueryCache, cachedAt)
	return err
}

const getAllCategorizedCards = `-- name: GetAllCategorizedCards :many
SELECT 
    c.oracle_id,
    c.name,
    c.layout,
    c.cmc,
    c.color_identity,
    c.colors,
    c.mana_cost,
    c.oracle_text,
    c.type_line,
    c.power,
    c.toughness,
    CASE 
        WHEN eae.oracle_id IS NOT NULL THEN 'Eternal Artisan Exception'
        WHEN aoea.oracle_id IS NOT NULL THEN 'Arena Only EA'
        WHEN bc.oracle_id IS NOT NULL THEN 'Banned'
        WHEN wc.oracle_id IS NOT NULL THEN 'Watchlist'
        WHEN dmc.oracle_id IS NOT NULL THEN 'Digital Mechanic'
        ELSE 'Unknown'
    END as category,
    COALESCE(dmc.mechanic_keyword, '') as mechanic_keyword
FROM cards c
LEFT JOIN eternal_artisan_exception eae ON c.oracle_id = eae.oracle_id
LEFT JOIN arena_only_ea_cards aoea ON c.oracle_id = aoea.oracle_id
LEFT JOIN banned_cards bc ON c.oracle_id = bc.oracle_id
LEFT JOIN watchlist_cards wc ON c.oracle_id = wc.oracle_id
LEFT JOIN digital_mechanic_cards dmc ON c.oracle_id = dmc.oracle_id
WHERE eae.oracle_id IS NOT NULL 
   OR aoea.oracle_id IS NOT NULL 
   OR bc.oracle_id IS NOT NULL 
   OR wc.oracle_id IS NOT NULL 
   OR dmc.oracle_id IS NOT NULL
ORDER BY category, c.name
`

type GetAllCategorizedCardsRow struct {
	OracleID        string
	Name            string
	Layout          string
	Cmc             float64
	ColorIdentity   string
	Colors          sql.NullString
	ManaCost        sql.NullString
	OracleText      sql.NullString
	TypeLine        string
	Power           sql.NullString
	Toughness       sql.NullString
	Category        string
	MechanicKeyword string
}

// Get all cards from all tables (one row per card)
func (q *Queries) GetAllCategorizedCards(ctx context.Context) ([]GetAllCategorizedCardsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllCategorizedCards)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllCategorizedCardsRow
	for rows.Next() {
		var i GetAllCategorizedCardsRow
		if err := rows.Scan(
			&i.OracleID,
			&i.Name,
			&i.Layout,
			&i.Cmc,
			&i.ColorIdentity,
			&i.Colors,
			&i.ManaCost,
			&i.OracleText,
			&i.TypeLine,
			&i.Power,
			&i.Toughness,
			&i.Category,
			&i.MechanicKeyword,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getArenaCardsByMechanic = `-- name: GetArenaCardsByMechanic :many
SELECT 
    c.oracle_id,
    c.name,
    c.layout,
    c.cmc,
    c.color_identity,
    c.colors,
    c.mana_cost,
    c.oracle_text,
    c.type_line,
    c.power,
    c.toughness
FROM cards c
JOIN arena_only_ea_cards aoea ON c.oracle_id = aoea.oracle_id
WHERE c.oracle_text IS NOT NULL AND c.oracle_text LIKE '%' || ? || '%'
ORDER BY c.name
`

type GetArenaCardsByMechanicRow struct {
	OracleID      string
	Name          string
	Layout        string
	Cmc           float64
	ColorIdentity string
	Colors        sql.NullString
	ManaCost      sql.NullString
	OracleText    sql.NullString
	TypeLine      string
	Power         sql.NullString
	Toughness     sql.NullString
}

// Get arena cards that contain specific mechanic in oracle text
func (q *Queries) GetArenaCardsByMechanic(ctx context.Context, dollar_1 sql.NullString) ([]GetArenaCardsByMechanicRow, error) {
	rows, err := q.db.QueryContext(ctx, getArenaCardsByMechanic, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetArenaCardsByMechanicRow
	for rows.Next() {
		var i GetArenaCardsByMechanicRow
		if err := rows.Scan(
			&i.OracleID,
			&i.Name,
			&i.Layout,
			&i.Cmc,
			&i.ColorIdentity,
			&i.Colors,
			&i.ManaCost,
			&i.OracleText,
			&i.TypeLine,
			&i.Power,
			&i.Toughness,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getArenaOnlyEACards = `-- name: GetArenaOnlyEACards :many
SELECT 
    c.oracle_id,
    c.name,
    c.layout,
    c.cmc,
    c.color_identity,
    c.colors,
    c.mana_cost,
    c.oracle_text,
    c.type_line,
    c.power,
    c.toughness,
    p.id as printing_id,
    p.rarity,
    p.games,
    p."set",
    p.set_name,
    p.released_at
FROM cards c
JOIN printings p ON c.oracle_id = p.oracle_id
JOIN arena_only_ea_cards aoea ON c.oracle_id = aoea.oracle_id
LEFT JOIN banned_cards bc ON c.oracle_id = bc.oracle_id
LEFT JOIN digital_mechanic_cards dmc ON c.oracle_id = dmc.oracle_id
WHERE bc.oracle_id IS NULL AND dmc.oracle_id IS NULL
ORDER BY c.name, p.released_at DESC
`

type GetArenaOnlyEACardsRow struct {
	OracleID      string
	Name          string
	Layout        string
	Cmc           float64
	ColorIdentity string
	Colors        sql.NullString
	ManaCost      sql.NullString
	OracleText    sql.NullString
	TypeLine      string
	Power         sql.NullString
	Toughness     sql.NullString
	PrintingID    string
	Rarity        string
	Games         string
	Set           string
	SetName       string
	ReleasedAt    string
}

// Get arena only EA cards with their printings, excluding banned cards
func (q *Queries) GetArenaOnlyEACards(ctx context.Context) ([]GetArenaOnlyEACardsRow, error) {
	rows, err := q.db.QueryContext(ctx, getArenaOnlyEACards)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetArenaOnlyEACardsRow
	for rows.Next() {
		var i GetArenaOnlyEACardsRow
		if err := rows.Scan(
			&i.OracleID,
			&i.Name,
			&i.Layout,
			&i.Cmc,
			&i.ColorIdentity,
			&i.Colors,
			&i.ManaCost,
			&i.OracleText,
			&i.TypeLine,
			&i.Power,
			&i.Toughness,
			&i.PrintingID,
			&i.Rarity,
			&i.Games,
			&i.Set,
			&i.SetName,
			&i.ReleasedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBannedCards = `-- name: GetBannedCards :many
SELECT 
    c.oracle_id,
    c.name,
    c.layout,
    c.cmc,
    c.color_identity,
    c.colors,
    c.mana_cost,
    c.oracle_text,
    c.type_line,
    c.power,
    c.toughness,
    p.id as printing_id,
    p.rarity,
    p.games,
    p."set",
    p.set_name,
    p.released_at,
    p.image_uris,
    bc.added_at
FROM cards c
JOIN banned_cards bc ON c.oracle_id = bc.oracle_id
LEFT JOIN printings p ON c.oracle_id = p.oracle_id
ORDER BY c.name, p.released_at DESC
`

type GetBannedCardsRow struct {
	OracleID      string
	Name          string
	Layout        string
	Cmc           float64
	ColorIdentity string
	Colors        sql.NullString
	ManaCost      sql.NullString
	OracleText    sql.NullString
	TypeLine      string
	Power         sql.NullString
	Toughness     sql.NullString
	PrintingID    sql.NullString
	Rarity        sql.NullString
	Games         sql.NullString
	Set           sql.NullString
	SetName       sql.NullString
	ReleasedAt    sql.NullString
	ImageUris     sql.NullString
	AddedAt       string
}

// Get banned cards with their card details
func (q *Queries) GetBannedCards(ctx context.Context) ([]GetBannedCardsRow, error) {
	rows, err := q.db.QueryContext(ctx, getBannedCards)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBannedCardsRow
	for rows.Next() {
		var i GetBannedCardsRow
		if err := rows.Scan(
			&i.OracleID,
			&i.Name,
			&i.Layout,
			&i.Cmc,
			&i.ColorIdentity,
			&i.Colors,
			&i.ManaCost,
			&i.OracleText,
			&i.TypeLine,
			&i.Power,
			&i.Toughness,
			&i.PrintingID,
			&i.Rarity,
			&i.Games,
			&i.Set,
			&i.SetName,
			&i.ReleasedAt,
			&i.ImageUris,
			&i.AddedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBestPrintingForImages = `-- name: GetBestPrintingForImages :one
SELECT 
    image_uris
FROM printings
WHERE oracle_id = ? AND image_uris IS NOT NULL AND image_uris != ''
ORDER BY 
    CASE WHEN games LIKE '%arena%' THEN 0 ELSE 1 END,
    released_at DESC
LIMIT 1
`

// Get the best printing for image data (prioritize Arena, then most recent)
func (q *Queries) GetBestPrintingForImages(ctx context.Context, oracleID string) (sql.NullString, error) {
	row := q.db.QueryRowContext(ctx, getBestPrintingForImages, oracleID)
	var image_uris sql.NullString
	err := row.Scan(&image_uris)
	return image_uris, err
}

const getCachedQuery = `-- name: GetCachedQuery :one

SELECT query_id, query_text, oracle_ids, cached_at, last_accessed, hit_count
FROM query_cache
WHERE query_text = ?
LIMIT 1
`

// Query Cache Operations
// Get cached query result
func (q *Queries) GetCachedQuery(ctx context.Context, queryText string) (QueryCache, error) {
	row := q.db.QueryRowContext(ctx, getCachedQuery, queryText)
	var i QueryCache
	err := row.Scan(
		&i.QueryID,
		&i.QueryText,
		&i.OracleIds,
		&i.CachedAt,
		&i.LastAccessed,
		&i.HitCount,
	)
	return i, err
}

const getCardByName = `-- name: GetCardByName :one
SELECT oracle_id, name, layout, cmc, color_identity, colors, mana_cost, oracle_text, type_line, power, toughness
FROM cards 
WHERE LOWER(name) = LOWER(?) 
LIMIT 1
`

type GetCardByNameRow struct {
	OracleID      string
	Name          string
	Layout        string
	Cmc           float64
	ColorIdentity string
	Colors        sql.NullString
	ManaCost      sql.NullString
	OracleText    sql.NullString
	TypeLine      string
	Power         sql.NullString
	Toughness     sql.NullString
}

// Get a card by exact name
func (q *Queries) GetCardByName(ctx context.Context, lower string) (GetCardByNameRow, error) {
	row := q.db.QueryRowContext(ctx, getCardByName, lower)
	var i GetCardByNameRow
	err := row.Scan(
		&i.OracleID,
		&i.Name,
		&i.Layout,
		&i.Cmc,
		&i.ColorIdentity,
		&i.Colors,
		&i.ManaCost,
		&i.OracleText,
		&i.TypeLine,
		&i.Power,
		&i.Toughness,
	)
	return i, err
}

const getCardByOracleID = `-- name: GetCardByOracleID :one
SELECT oracle_id, name, layout, cmc, color_identity, colors, mana_cost, oracle_text, type_line, power, toughness
FROM cards 
WHERE oracle_id = ? 
LIMIT 1
`

type GetCardByOracleIDRow struct {
	OracleID      string
	Name          string
	Layout        string
	Cmc           float64
	ColorIdentity string
	Colors        sql.NullString
	ManaCost      sql.NullString
	OracleText    sql.NullString
	TypeLine      string
	Power         sql.NullString
	Toughness     sql.NullString
}

// Get a card by oracle_id
func (q *Queries) GetCardByOracleID(ctx context.Context, oracleID string) (GetCardByOracleIDRow, error) {
	row := q.db.QueryRowContext(ctx, getCardByOracleID, oracleID)
	var i GetCardByOracleIDRow
	err := row.Scan(
		&i.OracleID,
		&i.Name,
		&i.Layout,
		&i.Cmc,
		&i.ColorIdentity,
		&i.Colors,
		&i.ManaCost,
		&i.OracleText,
		&i.TypeLine,
		&i.Power,
		&i.Toughness,
	)
	return i, err
}

const getCardsWithPrintings = `-- name: GetCardsWithPrintings :many
SELECT 
    c.oracle_id,
    c.name,
    c.layout,
    c.cmc,
    c.color_identity,
    c.colors,
    c.mana_cost,
    c.oracle_text,
    c.type_line,
    c.power,
    c.toughness,
    p.id as printing_id,
    p.rarity,
    p.games,
    p."set",
    p.set_name,
    p.released_at
FROM cards c
JOIN printings p ON c.oracle_id = p.oracle_id
ORDER BY c.name, p.released_at DESC
`

type GetCardsWithPrintingsRow struct {
	OracleID      string
	Name          string
	Layout        string
	Cmc           float64
	ColorIdentity string
	Colors        sql.NullString
	ManaCost      sql.NullString
	OracleText    sql.NullString
	TypeLine      string
	Power         sql.NullString
	Toughness     sql.NullString
	PrintingID    string
	Rarity        string
	Games         string
	Set           string
	SetName       string
	ReleasedAt    string
}

// Get all cards with their printings
func (q *Queries) GetCardsWithPrintings(ctx context.Context) ([]GetCardsWithPrintingsRow, error) {
	rows, err := q.db.QueryContext(ctx, getCardsWithPrintings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCardsWithPrintingsRow
	for rows.Next() {
		var i GetCardsWithPrintingsRow
		if err := rows.Scan(
			&i.OracleID,
			&i.Name,
			&i.Layout,
			&i.Cmc,
			&i.ColorIdentity,
			&i.Colors,
			&i.ManaCost,
			&i.OracleText,
			&i.TypeLine,
			&i.Power,
			&i.Toughness,
			&i.PrintingID,
			&i.Rarity,
			&i.Games,
			&i.Set,
			&i.SetName,
			&i.ReleasedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDigitalMechanicCards = `-- name: GetDigitalMechanicCards :many
SELECT 
    c.oracle_id,
    c.name,
    c.layout,
    c.cmc,
    c.color_identity,
    c.colors,
    c.mana_cost,
    c.oracle_text,
    c.type_line,
    c.power,
    c.toughness,
    p.id as printing_id,
    p.rarity,
    p.games,
    p."set",
    p.set_name,
    p.released_at,
    p.image_uris,
    dmc.mechanic_keyword,
    dmc.added_at
FROM cards c
JOIN digital_mechanic_cards dmc ON c.oracle_id = dmc.oracle_id
LEFT JOIN printings p ON c.oracle_id = p.oracle_id
ORDER BY c.name, p.released_at DESC
`

type GetDigitalMechanicCardsRow struct {
	OracleID        string
	Name            string
	Layout          string
	Cmc             float64
	ColorIdentity   string
	Colors          sql.NullString
	ManaCost        sql.NullString
	OracleText      sql.NullString
	TypeLine        string
	Power           sql.NullString
	Toughness       sql.NullString
	PrintingID      sql.NullString
	Rarity          sql.NullString
	Games           sql.NullString
	Set             sql.NullString
	SetName         sql.NullString
	ReleasedAt      sql.NullString
	ImageUris       sql.NullString
	MechanicKeyword sql.NullString
	AddedAt         string
}

// Get digital mechanic cards with their card details
func (q *Queries) GetDigitalMechanicCards(ctx context.Context) ([]GetDigitalMechanicCardsRow, error) {
	rows, err := q.db.QueryContext(ctx, getDigitalMechanicCards)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDigitalMechanicCardsRow
	for rows.Next() {
		var i GetDigitalMechanicCardsRow
		if err := rows.Scan(
			&i.OracleID,
			&i.Name,
			&i.Layout,
			&i.Cmc,
			&i.ColorIdentity,
			&i.Colors,
			&i.ManaCost,
			&i.OracleText,
			&i.TypeLine,
			&i.Power,
			&i.Toughness,
			&i.PrintingID,
			&i.Rarity,
			&i.Games,
			&i.Set,
			&i.SetName,
			&i.ReleasedAt,
			&i.ImageUris,
			&i.MechanicKeyword,
			&i.AddedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEternalArtisanCards = `-- name: GetEternalArtisanCards :many
SELECT 
    c.oracle_id,
    c.name,
    c.layout,
    c.cmc,
    c.color_identity,
    c.colors,
    c.mana_cost,
    c.oracle_text,
    c.type_line,
    c.power,
    c.toughness,
    p.id as printing_id,
    p.rarity,
    p.games,
    p."set",
    p.set_name,
    p.released_at
FROM cards c
JOIN printings p ON c.oracle_id = p.oracle_id
JOIN eternal_artisan_exception eae ON c.oracle_id = eae.oracle_id
LEFT JOIN banned_cards bc ON c.oracle_id = bc.oracle_id
LEFT JOIN digital_mechanic_cards dmc ON c.oracle_id = dmc.oracle_id
WHERE bc.oracle_id IS NULL AND dmc.oracle_id IS NULL
ORDER BY c.name, p.released_at DESC
`

type GetEternalArtisanCardsRow struct {
	OracleID      string
	Name          string
	Layout        string
	Cmc           float64
	ColorIdentity string
	Colors        sql.NullString
	ManaCost      sql.NullString
	OracleText    sql.NullString
	TypeLine      string
	Power         sql.NullString
	Toughness     sql.NullString
	PrintingID    string
	Rarity        string
	Games         string
	Set           string
	SetName       string
	ReleasedAt    string
}

// Get eternal artisan exception cards with their printings, excluding banned cards
func (q *Queries) GetEternalArtisanCards(ctx context.Context) ([]GetEternalArtisanCardsRow, error) {
	rows, err := q.db.QueryContext(ctx, getEternalArtisanCards)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEternalArtisanCardsRow
	for rows.Next() {
		var i GetEternalArtisanCardsRow
		if err := rows.Scan(
			&i.OracleID,
			&i.Name,
			&i.Layout,
			&i.Cmc,
			&i.ColorIdentity,
			&i.Colors,
			&i.ManaCost,
			&i.OracleText,
			&i.TypeLine,
			&i.Power,
			&i.Toughness,
			&i.PrintingID,
			&i.Rarity,
			&i.Games,
			&i.Set,
			&i.SetName,
			&i.ReleasedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPrintingsByOracleID = `-- name: GetPrintingsByOracleID :many
SELECT 
    id,
    oracle_id,
    set_name,
    "set" as set_code,
    rarity,
    games,
    image_uris,
    artist,
    collector_number,
    released_at,
    scryfall_uri
FROM printings
WHERE oracle_id = ?
ORDER BY released_at DESC
`

type GetPrintingsByOracleIDRow struct {
	ID              string
	OracleID        string
	SetName         string
	SetCode         string
	Rarity          string
	Games           string
	ImageUris       sql.NullString
	Artist          sql.NullString
	CollectorNumber string
	ReleasedAt      string
	ScryfallUri     string
}

// Get printings by oracle_id
func (q *Queries) GetPrintingsByOracleID(ctx context.Context, oracleID string) ([]GetPrintingsByOracleIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getPrintingsByOracleID, oracleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPrintingsByOracleIDRow
	for rows.Next() {
		var i GetPrintingsByOracleIDRow
		if err := rows.Scan(
			&i.ID,
			&i.OracleID,
			&i.SetName,
			&i.SetCode,
			&i.Rarity,
			&i.Games,
			&i.ImageUris,
			&i.Artist,
			&i.CollectorNumber,
			&i.ReleasedAt,
			&i.ScryfallUri,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getQueryCacheStats = `-- name: GetQueryCacheStats :one
SELECT 
    COUNT(*) as total_cached_queries,
    SUM(hit_count) as total_hits,
    AVG(hit_count) as avg_hits_per_query
FROM query_cache
`

type GetQueryCacheStatsRow struct {
	TotalCachedQueries int64
	TotalHits          sql.NullFloat64
	AvgHitsPerQuery    sql.NullFloat64
}

// Get query cache stats
func (q *Queries) GetQueryCacheStats(ctx context.Context) (GetQueryCacheStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getQueryCacheStats)
	var i GetQueryCacheStatsRow
	err := row.Scan(&i.TotalCachedQueries, &i.TotalHits, &i.AvgHitsPerQuery)
	return i, err
}

const getWatchlistCards = `-- name: GetWatchlistCards :many
SELECT 
    c.oracle_id,
    c.name,
    c.layout,
    c.cmc,
    c.color_identity,
    c.colors,
    c.mana_cost,
    c.oracle_text,
    c.type_line,
    c.power,
    c.toughness,
    p.id as printing_id,
    p.rarity,
    p.games,
    p."set",
    p.set_name,
    p.released_at,
    p.image_uris,
    wc.added_at
FROM cards c
JOIN watchlist_cards wc ON c.oracle_id = wc.oracle_id
LEFT JOIN printings p ON c.oracle_id = p.oracle_id
ORDER BY c.name, p.released_at DESC
`

type GetWatchlistCardsRow struct {
	OracleID      string
	Name          string
	Layout        string
	Cmc           float64
	ColorIdentity string
	Colors        sql.NullString
	ManaCost      sql.NullString
	OracleText    sql.NullString
	TypeLine      string
	Power         sql.NullString
	Toughness     sql.NullString
	PrintingID    sql.NullString
	Rarity        sql.NullString
	Games         sql.NullString
	Set           sql.NullString
	SetName       sql.NullString
	ReleasedAt    sql.NullString
	ImageUris     sql.NullString
	AddedAt       string
}

// Get watchlist cards with their card details
func (q *Queries) GetWatchlistCards(ctx context.Context) ([]GetWatchlistCardsRow, error) {
	rows, err := q.db.QueryContext(ctx, getWatchlistCards)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetWatchlistCardsRow
	for rows.Next() {
		var i GetWatchlistCardsRow
		if err := rows.Scan(
			&i.OracleID,
			&i.Name,
			&i.Layout,
			&i.Cmc,
			&i.ColorIdentity,
			&i.Colors,
			&i.ManaCost,
			&i.OracleText,
			&i.TypeLine,
			&i.Power,
			&i.Toughness,
			&i.PrintingID,
			&i.Rarity,
			&i.Games,
			&i.Set,
			&i.SetName,
			&i.ReleasedAt,
			&i.ImageUris,
			&i.AddedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertQueryCache = `-- name: InsertQueryCache :exec
INSERT INTO query_cache (query_text, oracle_ids)
VALUES (?, ?)
`

type InsertQueryCacheParams struct {
	QueryText string
	OracleIds string
}

// Insert new query cache entry
func (q *Queries) InsertQueryCache(ctx context.Context, arg InsertQueryCacheParams) error {
	_, err := q.db.ExecContext(ctx, insertQueryCache, arg.QueryText, arg.OracleIds)
	return err
}

const removeArenaOnlyEACard = `-- name: RemoveArenaOnlyEACard :exec
DELETE FROM arena_only_ea_cards WHERE oracle_id = ?
`

// Remove oracle_id from arena only EA cards table
func (q *Queries) RemoveArenaOnlyEACard(ctx context.Context, oracleID string) error {
	_, err := q.db.ExecContext(ctx, removeArenaOnlyEACard, oracleID)
	return err
}

const removeBannedCard = `-- name: RemoveBannedCard :exec
DELETE FROM banned_cards WHERE oracle_id = ?
`

// Remove oracle_id from banned cards table
func (q *Queries) RemoveBannedCard(ctx context.Context, oracleID string) error {
	_, err := q.db.ExecContext(ctx, removeBannedCard, oracleID)
	return err
}

const removeDigitalMechanicCard = `-- name: RemoveDigitalMechanicCard :exec
DELETE FROM digital_mechanic_cards WHERE oracle_id = ?
`

// Remove oracle_id from digital mechanic cards table
func (q *Queries) RemoveDigitalMechanicCard(ctx context.Context, oracleID string) error {
	_, err := q.db.ExecContext(ctx, removeDigitalMechanicCard, oracleID)
	return err
}

const removeEternalArtisanException = `-- name: RemoveEternalArtisanException :exec
DELETE FROM eternal_artisan_exception WHERE oracle_id = ?
`

// Remove oracle_id from eternal artisan exception table
func (q *Queries) RemoveEternalArtisanException(ctx context.Context, oracleID string) error {
	_, err := q.db.ExecContext(ctx, removeEternalArtisanException, oracleID)
	return err
}

const removeWatchlistCard = `-- name: RemoveWatchlistCard :exec
DELETE FROM watchlist_cards WHERE oracle_id = ?
`

// Remove oracle_id from watchlist cards table
func (q *Queries) RemoveWatchlistCard(ctx context.Context, oracleID string) error {
	_, err := q.db.ExecContext(ctx, removeWatchlistCard, oracleID)
	return err
}

const updateQueryCacheHit = `-- name: UpdateQueryCacheHit :exec
UPDATE query_cache
SET hit_count = hit_count + 1,
    last_accessed = CURRENT_TIMESTAMP
WHERE query_text = ?
`

// Update query cache hit (increment hit count and update last_accessed)
func (q *Queries) UpdateQueryCacheHit(ctx context.Context, queryText string) error {
	_, err := q.db.ExecContext(ctx, updateQueryCacheHit, queryText)
	return err
}

const upsertCard = `-- name: UpsertCard :exec
INSERT INTO cards (
    oracle_id, name, layout, prints_search_uri, rulings_uri,
    all_parts, card_faces, cmc, color_identity, color_indicator, colors,
    defense, edhrec_rank, game_changer, hand_modifier, keywords, legalities,
    life_modifier, loyalty, mana_cost, oracle_text, penny_rank, power,
    produced_mana, reserved, toughness, type_line
) VALUES (
    ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
)
ON CONFLICT(oracle_id) DO UPDATE SET
    name = excluded.name,
    layout = excluded.layout,
    prints_search_uri = excluded.prints_search_uri,
    rulings_uri = excluded.rulings_uri,
    all_parts = excluded.all_parts,
    card_faces = excluded.card_faces,
    cmc = excluded.cmc,
    color_identity = excluded.color_identity,
    color_indicator = excluded.color_indicator,
    colors = excluded.colors,
    defense = excluded.defense,
    edhrec_rank = excluded.edhrec_rank,
    game_changer = excluded.game_changer,
    hand_modifier = excluded.hand_modifier,
    keywords = excluded.keywords,
    legalities = excluded.legalities,
    life_modifier = excluded.life_modifier,
    loyalty = excluded.loyalty,
    mana_cost = excluded.mana_cost,
    oracle_text = excluded.oracle_text,
    penny_rank = excluded.penny_rank,
    power = excluded.power,
    produced_mana = excluded.produced_mana,
    reserved = excluded.reserved,
    toughness = excluded.toughness,
    type_line = excluded.type_line
`

type UpsertCardParams struct {
	OracleID        string
	Name            string
	Layout          string
	PrintsSearchUri string
	RulingsUri      string
	AllParts        sql.NullString
	CardFaces       sql.NullString
	Cmc             float64
	ColorIdentity   string
	ColorIndicator  sql.NullString
	Colors          sql.NullString
	Defense         sql.NullString
	EdhrecRank      sql.NullInt64
	GameChanger     sql.NullBool
	HandModifier    sql.NullString
	Keywords        string
	Legalities      string
	LifeModifier    sql.NullString
	Loyalty         sql.NullString
	ManaCost        sql.NullString
	OracleText      sql.NullString
	PennyRank       sql.NullInt64
	Power           sql.NullString
	ProducedMana    sql.NullString
	Reserved        bool
	Toughness       sql.NullString
	TypeLine        string
}

// Insert or update a card (oracle-level)
func (q *Queries) UpsertCard(ctx context.Context, arg UpsertCardParams) error {
	_, err := q.db.ExecContext(ctx, upsertCard,
		arg.OracleID,
		arg.Name,
		arg.Layout,
		arg.PrintsSearchUri,
		arg.RulingsUri,
		arg.AllParts,
		arg.CardFaces,
		arg.Cmc,
		arg.ColorIdentity,
		arg.ColorIndicator,
		arg.Colors,
		arg.Defense,
		arg.EdhrecRank,
		arg.GameChanger,
		arg.HandModifier,
		arg.Keywords,
		arg.Legalities,
		arg.LifeModifier,
		arg.Loyalty,
		arg.ManaCost,
		arg.OracleText,
		arg.PennyRank,
		arg.Power,
		arg.ProducedMana,
		arg.Reserved,
		arg.Toughness,
		arg.TypeLine,
	)
	return err
}

const upsertPrinting = `-- name: UpsertPrinting :exec
INSERT INTO printings (
    id, oracle_id, arena_id, lang, mtgo_id, mtgo_foil_id, multiverse_ids,
    tcgplayer_id, tcgplayer_etched_id, cardmarket_id, object, scryfall_uri, uri,
    artist, artist_ids, attraction_lights, booster, border_color, card_back_id,
    collector_number, content_warning, digital, finishes, flavor_name, flavor_text,
    foil, nonfoil, frame_effects, frame, full_art, games, highres_image,
    illustration_id, image_status, image_uris, oversized, prices, printed_name,
    printed_text, printed_type_line, promo, promo_types, purchase_uris, rarity,
    related_uris, released_at, reprint, scryfall_set_uri, set_name, set_search_uri,
    set_type, set_uri, "set", set_id, story_spotlight, textless, variation,
    variation_of, security_stamp, watermark, preview
) VALUES (
    ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,
    ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,
    ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
)
ON CONFLICT(id) DO UPDATE SET
    oracle_id = excluded.oracle_id,
    arena_id = excluded.arena_id,
    lang = excluded.lang,
    mtgo_id = excluded.mtgo_id,
    mtgo_foil_id = excluded.mtgo_foil_id,
    multiverse_ids = excluded.multiverse_ids,
    tcgplayer_id = excluded.tcgplayer_id,
    tcgplayer_etched_id = excluded.tcgplayer_etched_id,
    cardmarket_id = excluded.cardmarket_id,
    object = excluded.object,
    scryfall_uri = excluded.scryfall_uri,
    uri = excluded.uri,
    artist = excluded.artist,
    artist_ids = excluded.artist_ids,
    attraction_lights = excluded.attraction_lights,
    booster = excluded.booster,
    border_color = excluded.border_color,
    card_back_id = excluded.card_back_id,
    collector_number = excluded.collector_number,
    content_warning = excluded.content_warning,
    digital = excluded.digital,
    finishes = excluded.finishes,
    flavor_name = excluded.flavor_name,
    flavor_text = excluded.flavor_text,
    foil = excluded.foil,
    nonfoil = excluded.nonfoil,
    frame_effects = excluded.frame_effects,
    frame = excluded.frame,
    full_art = excluded.full_art,
    games = excluded.games,
    highres_image = excluded.highres_image,
    illustration_id = excluded.illustration_id,
    image_status = excluded.image_status,
    image_uris = excluded.image_uris,
    oversized = excluded.oversized,
    prices = excluded.prices,
    printed_name = excluded.printed_name,
    printed_text = excluded.printed_text,
    printed_type_line = excluded.printed_type_line,
    promo = excluded.promo,
    promo_types = excluded.promo_types,
    purchase_uris = excluded.purchase_uris,
    rarity = excluded.rarity,
    related_uris = excluded.related_uris,
    released_at = excluded.released_at,
    reprint = excluded.reprint,
    scryfall_set_uri = excluded.scryfall_set_uri,
    set_name = excluded.set_name,
    set_search_uri = excluded.set_search_uri,
    set_type = excluded.set_type,
    set_uri = excluded.set_uri,
    "set" = excluded."set",
    set_id = excluded.set_id,
    story_spotlight = excluded.story_spotlight,
    textless = excluded.textless,
    variation = excluded.variation,
    variation_of = excluded.variation_of,
    security_stamp = excluded.security_stamp,
    watermark = excluded.watermark,
    preview = excluded.preview
`

type UpsertPrintingParams struct {
	ID                string
	OracleID          string
	ArenaID           sql.NullInt64
	Lang              string
	MtgoID            sql.NullInt64
	MtgoFoilID        sql.NullInt64
	MultiverseIds     sql.NullString
	TcgplayerID       sql.NullInt64
	TcgplayerEtchedID sql.NullInt64
	CardmarketID      sql.NullInt64
	Object            string
	ScryfallUri       string
	Uri               string
	Artist            sql.NullString
	ArtistIds         sql.NullString
	AttractionLights  sql.NullString
	Booster           bool
	BorderColor       string
	CardBackID        string
	CollectorNumber   string
	ContentWarning    sql.NullBool
	Digital           bool
	Finishes          string
	FlavorName        sql.NullString
	FlavorText        sql.NullString
	Foil              bool
	Nonfoil           bool
	FrameEffects      sql.NullString
	Frame             string
	FullArt           bool
	Games             string
	HighresImage      bool
	IllustrationID    sql.NullString
	ImageStatus       string
	ImageUris         sql.NullString
	Oversized         bool
	Prices            string
	PrintedName       sql.NullString
	PrintedText       sql.NullString
	PrintedTypeLine   sql.NullString
	Promo             bool
	PromoTypes        sql.NullString
	PurchaseUris      sql.NullString
	Rarity            string
	RelatedUris       string
	ReleasedAt        string
	Reprint           bool
	ScryfallSetUri    string
	SetName           string
	SetSearchUri      string
	SetType           string
	SetUri            string
	Set               string
	SetID             string
	StorySpotlight    bool
	Textless          bool
	Variation         bool
	VariationOf       sql.NullString
	SecurityStamp     sql.NullString
	Watermark         sql.NullString
	Preview           sql.NullString
}

// Insert or update a printing
func (q *Queries) UpsertPrinting(ctx context.Context, arg UpsertPrintingParams) error {
	_, err := q.db.ExecContext(ctx, upsertPrinting,
		arg.ID,
		arg.OracleID,
		arg.ArenaID,
		arg.Lang,
		arg.MtgoID,
		arg.MtgoFoilID,
		arg.MultiverseIds,
		arg.TcgplayerID,
		arg.TcgplayerEtchedID,
		arg.CardmarketID,
		arg.Object,
		arg.ScryfallUri,
		arg.Uri,
		arg.Artist,
		arg.ArtistIds,
		arg.AttractionLights,
		arg.Booster,
		arg.BorderColor,
		arg.CardBackID,
		arg.CollectorNumber,
		arg.ContentWarning,
		arg.Digital,
		arg.Finishes,
		arg.FlavorName,
		arg.FlavorText,
		arg.Foil,
		arg.Nonfoil,
		arg.FrameEffects,
		arg.Frame,
		arg.FullArt,
		arg.Games,
		arg.HighresImage,
		arg.IllustrationID,
		arg.ImageStatus,
		arg.ImageUris,
		arg.Oversized,
		arg.Prices,
		arg.PrintedName,
		arg.PrintedText,
		arg.PrintedTypeLine,
		arg.Promo,
		arg.PromoTypes,
		arg.PurchaseUris,
		arg.Rarity,
		arg.RelatedUris,
		arg.ReleasedAt,
		arg.Reprint,
		arg.ScryfallSetUri,
		arg.SetName,
		arg.SetSearchUri,
		arg.SetType,
		arg.SetUri,
		arg.Set,
		arg.SetID,
		arg.StorySpotlight,
		arg.Textless,
		arg.Variation,
		arg.VariationOf,
		arg.SecurityStamp,
		arg.Watermark,
		arg.Preview,
	)
	return err
}
